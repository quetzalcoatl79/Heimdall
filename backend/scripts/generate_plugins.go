//go:build ignore
// +build ignore

// This script scans the plugins directory and generates the plugin registry.
// Run with: go run scripts/generate_plugins.go

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"gopkg.in/yaml.v3"
)

// PluginManifest represents the plugin.yaml structure
type PluginManifest struct {
	Name               string   `yaml:"name"`
	Version            string   `yaml:"version"`
	Description        string   `yaml:"description"`
	Author             string   `yaml:"author"`
	SystemDependencies []string `yaml:"system_dependencies"`
	GoDependencies     []string `yaml:"go_dependencies"`
	NpmDependencies    []string `yaml:"npm_dependencies"`
	Menu               struct {
		Label    string `yaml:"label"`
		Icon     string `yaml:"icon"`
		Position int    `yaml:"position"`
	} `yaml:"menu"`
	Permissions []string `yaml:"permissions"`
}

func main() {
	// Find project root (where go.mod is)
	projectRoot, err := findProjectRoot()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error finding project root: %v\n", err)
		os.Exit(1)
	}

	pluginsDir := filepath.Join(projectRoot, "..", "plugins")
	builtinDir := filepath.Join(projectRoot, "internal", "plugins", "builtin")
	outputFile := filepath.Join(projectRoot, "internal", "plugins", "builtin", "generated.go")

	fmt.Printf("Scanning plugins in: %s\n", pluginsDir)
	fmt.Printf("Scanning builtin in: %s\n", builtinDir)

	var plugins []string

	// Scan external plugins directory
	if entries, err := os.ReadDir(pluginsDir); err == nil {
		for _, entry := range entries {
			if !entry.IsDir() || entry.Name() == "README.md" {
				continue
			}
			pluginPath := filepath.Join(pluginsDir, entry.Name())
			
			// Check for plugin.yaml or backend/plugin.go
			if hasPluginBackend(pluginPath) {
				plugins = append(plugins, entry.Name())
				fmt.Printf("  Found external plugin: %s\n", entry.Name())
			}
		}
	}

	// Scan builtin plugins directory
	if entries, err := os.ReadDir(builtinDir); err == nil {
		for _, entry := range entries {
			if !entry.IsDir() {
				continue
			}
			pluginPath := filepath.Join(builtinDir, entry.Name())
			
			// Check for *.go files
			if hasGoFiles(pluginPath) {
				plugins = append(plugins, "builtin/"+entry.Name())
				fmt.Printf("  Found builtin plugin: %s\n", entry.Name())
			}
		}
	}

	sort.Strings(plugins)

	// Generate the registry file
	code := generateRegistryCode(plugins)
	
	// Format the code
	formatted, err := format.Source([]byte(code))
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error formatting generated code: %v\n", err)
		fmt.Println("Generated code:")
		fmt.Println(code)
		os.Exit(1)
	}

	// Write the file
	if err := os.WriteFile(outputFile, formatted, 0644); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing output file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated: %s with %d plugins\n", outputFile, len(plugins))
}

func findProjectRoot() (string, error) {
	dir, err := os.Getwd()
	if err != nil {
		return "", err
	}

	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir, nil
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			return "", fmt.Errorf("go.mod not found")
		}
		dir = parent
	}
}

func hasPluginBackend(pluginPath string) bool {
	// Check for plugin.yaml
	if _, err := os.Stat(filepath.Join(pluginPath, "plugin.yaml")); err == nil {
		return true
	}
	// Check for backend/plugin.go
	if _, err := os.Stat(filepath.Join(pluginPath, "backend", "plugin.go")); err == nil {
		return true
	}
	// Check for any .go file in backend/
	backendDir := filepath.Join(pluginPath, "backend")
	if entries, err := os.ReadDir(backendDir); err == nil {
		for _, e := range entries {
			if strings.HasSuffix(e.Name(), ".go") {
				return true
			}
		}
	}
	return false
}

func hasGoFiles(dir string) bool {
	entries, err := os.ReadDir(dir)
	if err != nil {
		return false
	}
	for _, e := range entries {
		if strings.HasSuffix(e.Name(), ".go") {
			return true
		}
	}
	return false
}

func generateRegistryCode(plugins []string) string {
	var buf bytes.Buffer

	buf.WriteString(`// Code generated by scripts/generate_plugins.go. DO NOT EDIT.
// Run 'make plugins' to regenerate.

package builtin

import (
`)

	// Generate imports
	for _, p := range plugins {
		if strings.HasPrefix(p, "builtin/") {
			// Builtin plugin
			name := strings.TrimPrefix(p, "builtin/")
			buf.WriteString(fmt.Sprintf("\t_ \"github.com/nxo/engine/internal/plugins/builtin/%s\"\n", name))
		} else {
			// External plugin - would need custom import path
			// For now, we'll handle this differently
			buf.WriteString(fmt.Sprintf("\t// External plugin: %s (requires manual import)\n", p))
		}
	}

	buf.WriteString(`)

// init ensures all plugins are registered via their init() functions.
// This file is auto-generated - do not edit manually.
func init() {
	// All plugins are registered via their own init() functions
	// through the blank imports above.
}
`)

	return buf.String()
}
